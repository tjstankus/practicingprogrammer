---
layout: post
title:  "The Value of Code Exercises"
date:   2017-05-22
---

*This article is the first in a [series](/series) on code exercises.*

I've had the great good fortune to participate in [Sandi Metz's Practical
Object-Oriented Design Course](https://www.sandimetz.com/courses/), both as
student and co-instructor. The curriculum teaches OO principles through a series
of code exercises. Despite being easy to understand, the exercises impart a
disproportionately deep amount of learning (and teaching).

When the idea of code exercises comes up amongst developers, almost certainly
some will disparage them as toys, dissociated from the complex, large codebases
they inhabit for a living. We've come to expect complexity in our day jobs.
We're asked to solve formidable problems, and as if that isn't difficult enough,
we're asked to do it under unrealistic deadlines, working with code that we
didn't write, don't like, and cannot possibly understand quickly. It's no wonder
that developers accustomed to these kinds of pressures, when sitting down to
write a greenfield solution to a simple problem, see no relevance to their
day-to-day work. The experience feels too far removed. But the absence of
everyday work constraints is precisely what makes working on code exercises
valuable.

## Our best work

Programming is about decomposing and simplifying problems. When we work on
problems of modest size, that we solve from scratch, we focus our efforts around
this fundamental quality of programming. When we allow ourselves time to
explore, we unloose our intellectual curiosity, absolved from deadlines and the
constraints placed upon us by building on top of code we neither wrote nor
conceived. We can double down on simplicity and elegance. We can craft solutions
that follow the principles of clean code, that we know are good and right, but
that we so often, perhaps even habitually, eschew under externally-imposed
pressures. We are free to do our best work.

Without knowing our best work, we diminish our abilities when confronted with
larger codebases and more complex problems. Much like building substantial LEGO
structures from small bricks, our larger codebases should be small collections
of decoupled, reusable, flexible abstractions. They should be an assemblage of
the very kinds of solutions that we come up with when tackling small problems.

To extract full value from a code exercise, it's not enough to get the tests
passing and move on. It requires that we exercise the freedom to experiment and
resolve to do our best work. It requires that we forget about the time-to-market
sensibility that guides our for-pay work, and simply play. While practicing on a
code exercise, when we ask ourselves, "What if?", we should feel compelled to
follow our intellectual curiosities.

## Practice is play

Though I've framed this approach to exercise as play, and it is, it should also
be considered practice. The things we learn in practice are, of course, directly
applicable to our work when the pressure is on. An elegant solution we discover
through practice may be a good fit for our next work task. Without having
practiced and internalized elegant approaches, we're likely to think of an
inferior approach first, and under pressure, the first thing we think of is
often the most practical path to follow.

Many of us were originally enthralled by programming through a spirit of
curiosity and inquiry. Honor that spirit by pushing the boundaries of your
knowledge, by diving deep into simplicity, by trying wild and new approaches. A
commitment to spending time on exploration and practice is one of the 
highest-yield investments we can make in advancing our programming skills.

In the next article in this [series](/series), I'll put my money where my mouth
is and walk through a thoroughly decomposed solution to a well-known but
sneakily complex code exercise.
