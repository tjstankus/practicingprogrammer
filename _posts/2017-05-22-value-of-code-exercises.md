---
layout: post
title:  "The Value of Code Exercises"
date:   2017-05-22
---

I've had the great good fortune to participate in [Sandi Metz's Practical
Object-Oriented Design Course](https://www.sandimetz.com/courses/), both as
student and co-instructor. The curriculum teaches OO principles and practices
through a series of code exercises. Despite being small and easy to understand,
the exercises impart a disproportionately deep amount of learning (and
teaching).

When the idea of code exercises comes up amongst developers, almost certainly
someone will disparage them as toys and not relevant to the complex, large
codebases they inhabit for a living. We've come to expect complexity in our day
jobs. We're asked to solve formidable, hairy problems, and as if that isn't
difficult enough, it's often under unrealistic deadlines, working with code that
we didn't write, don't like, and cannot possibly understand quickly. It's no
wonder that developers accustomed to these kinds of pressures, when sitting down
to write a greenfield solution to an easily-grokkable problem, see no relevance
to their day-to-day work. The experience feels too far removed. But the absence
of everyday work constraints is precisely what makes working on code exercises
valuable.

Programming is about decomposing and simplifying problems. When we work on
problems of modest size, that we solve from scratch, we focus our efforts around
this fundamental quality of programming. When we allow ourselves time to explore
code exercises, we unloose our intellectual curiosity, absolved from
deadlines and the constraints placed upon us by building on top of
code we neither wrote nor conceived. We can double down on simplicity and
elegance. We can craft solutions that follow the principles of clean code, that
we know are good and right, but that we so often, perhaps even habitually,
eschew under externally-imposed pressures. In other words, we are free to do our
best work.

Without knowing our best work, we diminish our abilities when confronted with
larger codebases and more complex problems. Much like building substantial LEGO
structures from small bricks, our larger codebases should be small collections
of decoupled, reusable, flexible abstractions. They should be an assemblage of
the very kinds of solutions that we come up with when tackling small problems.

To extract full value from a code exercise, it's not enough to get the tests
passing and move on. It requires that we exercise the freedom to experiment and
resolve to do our best work. It requires that we forget about the time-to-market
sensibility that guides our for-pay work, and simply play. While practicing on a
code exercise, when we ask ourselves, "What if?", we should feel compelled to
follow our intellectual curiosities.

Though I've framed this approach to exercise as play, and it is, it should also
be considered practice. The things we learn in practice are, of course, directly
applicable to our work when the pressure is on. An elegant solution we discover
through practice may be a good fit for our next work task. Without having
practiced and internalized elegant approaches, we're likely to think of an
inferior approach first, and under pressure, the first thing we think of is
often the most practical path to follow.

Many of us were attracted to programming in the first place by a spirit of
curiosity and inquiry. Honor that spirit by pushing the boundaries of your
knowledge, by diving deep into simplicity, by trying new approaches. A
commitment to spending time on exploration and practice is one of the the
highest-yield investments we can make in advancing our programming skills.

In the next article in this series, I'll put my money where my mouth is and walk
through a thoroughly decomposed solution to a well-known but sneakily complex
code exercise.
