# Value of code exercises (working title)

## Ideas to incorporate

- Design exercises are not the same as code exercises. Give yourself challenges.
  Examples.
- Perhaps just reveal the latest Ruby exercise. Follow up later with new games,
  Elixir, etc. Don't worry so much about the secret sauce. This is interesting
  work that I'm doing and I'd rather share it multiple times than not at all,
  even at the risk of losing a little bit of money over it. It might actually
  gain me money if the blog post works as an ad for the book.
- From previous draft remove: West End stuff, at least change 99B stuff if keep
  it at all.

## Previous draft

I've been hosting monthly West End Ruby meetups [ link ] for the better part of
six years. While I've always enjoyed them and received positive feedback from
attendees, the last few have been the best so far. Why? Because we've worked on
code exercises as a group. It has brought a renewed energy; we've hit our
attendee cap each of the past four months.

Despite the fact that I'm one of the more experienced developers in the group
and that I work on the exercise ahead of time, I've learned something at each of
these meetups. At first this surprised me, but shouldn't have, because it
underscores something I already knew, but perhaps didn't fully accept: doing
small code exercises is one of the most valuable, deep learning experiences we
can give ourselves as a developers.

I've had the great good fortune to participate in Sandi Metz's POOD Course [
link ] both as student and co-instructor. The curriculum teaches object-oriented
programming principles and practices through a series of code exercises. The
exercises are minimal and easy to grok. But despite these qualities, the amount
one can learn (and teach) runs disproportionately deep. Course attendees I've
spoken with, to a person, have raved about how much practical knowledge they've
gained and are eager to apply in their jobs.

Yet, when the idea of small code exercises comes up amongst developers, almost
certainly someone will express the sentiment that these kinds of exercises are
toys and not relevant to the complex, large codebases they inhabit for a living.

It's true that we deal with complexity in our day-to-day jobs. We're asked to
solve formidable, hairy problems, and as if that isn't difficult enough, we're
often asked to do so under unrealistic deadlines, working with code that we
didn't write and cannot possibly understand under time constraints. It's no
wonder that developers used to these kinds of daily pressures, when sitting down
to write a greenfield solution to an easily-grokkable problem, see no relevance
to their day jobs. The experience feels too far removed from their daily work
experiences.  But I would argue that the absence of day-to-day work pressures
and constraints is precisely what makes working on code exercises valuable.

Programming is about breaking down problems into their essence. In other words,
simplifying. When we work on grokkable problems that we solve from scratch, we
can focus our efforts around this fundamental quality of programming. We can
exercise our intellectual curiosity, free from the pressures of time and free
from the constraints placed upon us by building on top of code we did not write
nor conceive.  Free to focus on simplicity and elegance, we can craft solutions
that follow the principles of clean code, that we know are good and right, but
that we so often, perhaps even habitually, eschew under externally-imposed
pressures. In other words, we are free to do our best work.

Without this kind of freedom to apply principles of good design in a small code
exercise, we diminish our ability to apply them to larger codebases and more
complex problems. Much like building substantial LEGO structures from small
bricks, our larger codebases should be collections of small, decoupled,
reusable, flexible abstractions. They should be a collection of instances of the
very kinds of solutions that we come up with when working on small problems.

But it takes a certain approach to working on code exercises to get this kind of
value. It requires not just functioning code, but in pushing ourselves to do our
best work. It requires that we exercise the freedom to experiment. It requires
that we forget about the time-to-market sensibility that guides our for-pay
work, and simply play. While practicing on a code exercise, when we ask
ourselves, "What if?", we should feel free and compelled to follow our
intellectual curiosities.

Though I've framed this approach to exercise as play, and it is, it can also be
considered practice. The things we learn in practice are, of course, directly
applicable to our work activities when the pressure is on. An elegant solution
we discovered while experimenting with a code exercise that is fresh on our
minds may very well be a good fit for our next work task. Without having played
(errr practiced) with that elegant approach, we're likely to think of an
inferior approach first, and under pressure, the first thing we think of is
often the most practical path to follow.

I'm not going out on a limb here, asserting that doing code exercises, much like
doing physical exercise, is beneficial. But to extract the full value of working
on code exercises takes a mindset change. We should allow ourselves the freedom
to push the boundaries of our knowledge by diving deep, by trying new
approaches, and by following the spirit of curiosity and inquiry that likely
attracted us to programming in the first place. I consider a commitment to
spending time on fun and practice one of the the highest-yield investments one
can make in improving programming skills.

But you don't have to take my word for it. Sandi Metz and Katrina Owen are
publishing a book [ link ] that takes a deep dive into a single, small code
exercise. I've been exposed to some of this content in the aforementioned POOD
courses [ link ] and I've read early drafts of the book. I think it will change
the way you write and think about code, and perhaps, the deep learning potential
of code exercises.
